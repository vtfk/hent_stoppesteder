# -*- coding: utf-8 -*-
"""
/***************************************************************************
 loadStopPlacesBuss
                                 A QGIS plugin
 Henter stoppesteder i vestfold og telemark, bus.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-09-22
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Vestfold og Telemark Fylkeskommune, ved Robin Ellingsen
        email                : robin.ellingsen@vtfk.no
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from os import path

from qgis.core import *
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QTimer
from qgis.PyQt.QtGui import *
from qgis.utils import iface
from qgis.PyQt.QtWidgets import QAction
from qgis.core import QgsVectorLayer, QgsProject, QgsMessageLog, QgsRasterLayer, QgsLayerDefinition
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .Hent_Stoppesteder_dialog import loadStopPlacesBussDialog

import os.path
import csv
import os
import pandas as pd
import requests
import zipfile
import io

file = ('results_stops_vtfk.csv')
file_t = ('results_stops_telemark.csv')
file_v = ('results_stops_vestfold.csv')
write_to_file = ''
class loadStopPlacesBuss:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        self.dlg = loadStopPlacesBussDialog()
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'loadStopPlacesBuss_{}.qm'.format(locale))

        if os.path.exists(locale_path):

            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Hent Stoppesteder')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('loadStopPlacesBuss', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        icon_path = ':/plugins/Hent Stoppesteder/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Hent Stoppesteder'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Hent Stoppesteder'),
                action)
            self.iface.removeToolBarIcon(action)

    def get_telemark(self):
        # Get the stops from Telemark

        url_telemark = 'https://storage.googleapis.com/marduk-production/outbound/gtfs/rb_tel-aggregated-gtfs.zip'
        request_telemark = requests.get(url_telemark, allow_redirects=True)

        """Check if the request is ok"""
        if request_telemark.ok:
            return request_telemark
        else:
            return QgsMessageLog.logMessage('Feilet ved henting av stoppestedene i Telemark')

    def get_vestfold(self):
        # Get the stops from Vestfold

        url_vestfold = 'https://storage.googleapis.com/marduk-production/outbound/gtfs/rb_vkt-aggregated-gtfs.zip'
        request_vestfold = requests.get(url_vestfold, allow_redirects=True)

        """Check if the request is ok"""
        if request_vestfold.ok:
            return request_vestfold
        else:
            return QgsMessageLog.logMessage('Feilet ved henting av stoppestedene i Vestfold')

    def process_files_vestfold(self):
        # Process the file from the get_vestfold method.

        request_vestfold = self.get_vestfold()

        vestfold_data_zip = zipfile.ZipFile(io.BytesIO(request_vestfold.content))
        vestfold_data_zip_namelist = vestfold_data_zip.namelist()

        file_vestfold = './filer/vestfold/stops.txt'
        if path.isfile(file_vestfold):
            os.remove(file_vestfold)
            for name in vestfold_data_zip_namelist:
                if name == 'stops.txt':
                    vestfold_data_zip.extract('stops.txt', './filer/vestfold')
                else:
                    pass
            QgsMessageLog.logMessage("Sletter gamle filer og laster ned nye")

            for name in vestfold_data_zip_namelist:
                if name == 'stops.txt':
                    vestfold_data_zip.extract('stops.txt', './filer/vestfold')
                else:
                    pass
            QgsMessageLog.logMessage("Det finnes ingen filer, laster ned filene")

    def process_files_telemark(self):
        # Process the file from the get_telemark method.

        request_telemark = self.get_telemark()

        telemark_data_zip = zipfile.ZipFile(io.BytesIO(request_telemark.content))
        telemark_data_zip_namelist = telemark_data_zip.namelist()

        file_telemark = './filer/telemark/stops.txt'
        if path.isfile(file_telemark):
            os.remove(file_telemark)
            for name in telemark_data_zip_namelist:
                if name == 'stops.txt':
                    telemark_data_zip.extract('stops.txt', './filer/telemark')
                else:
                    pass
            QgsMessageLog.logMessage("Sletter gamle filer og laster ned nye")
        else:
            for name in telemark_data_zip_namelist:
                if name == 'stops.txt':
                    telemark_data_zip.extract('stops.txt', './filer/telemark')
                else:
                    pass
            QgsMessageLog.logMessage("Det finnes ingen filer, laster ned filene")

    def combine_files(self):
        # Combine the files so the user is able to view the two files as one layer in qgis.

        with open('./filer/telemark/stops.txt', 'r') as ftlm:
            data_tlm = ftlm.read().splitlines(True)
            ftlm.close()
        with open('./filer/telemark/stops.txt', 'w') as ftl:
            ftl.writelines(data_tlm[1:])
            ftl.close()
        with open('./filer/telemark/stops.txt', 'r') as ft:
            data_removed_header = ft.read()
            ft.close()
        with open('./filer/vestfold/stops.txt', 'r') as fvkt:
            data_vkt = fvkt.read()
            fvkt.close()

        data_vkt += "\n"
        data_vkt += data_removed_header

        with open(file, 'w') as fr:
            fr.write(data_vkt)
            fr.close()

    def file_telemark(self):
        with open('./filer/telemark/stops.txt', 'r') as ft:
            data_telemark = ft.read()
            ft.close()

        # Set the col values for the file.
        with open(file_t, 'w') as fr:
            fr.write('stop_id,stop_name,stop_lat,stop_lon,stop_desc,location_type,parent_station,wheelchair_boarding,vehicle_type,platform_code')
            fr.write(data_telemark)
            fr.close()

    def file_vestfold(self):
        with open('./filer/vestfold/stops.txt', 'r') as fvkt:
            data_vestfold = fvkt.read()
            fvkt.close()
            with open(file_v, 'w') as fr:
                fr.write(data_vestfold)
                fr.close()

    def remove_vehicle_type(self):
        # Set the correct file and remove unwanted vehicle type.
        global write_to_file
        if self.dlg.checkBox_begge.isChecked():
            write_to_file = file
        elif self.dlg.checkBox_telemark.isChecked():
            write_to_file = file_t
        elif self.dlg.checkBox_vestfold.isChecked():
            write_to_file = file_v

        lines = list()
        with open(write_to_file, 'r') as f:
            reader = csv.reader(f)
            for row in reader:
                lines.append(row)
                for field in row:
                    if field == "1000":  # 1000 = båt
                        lines.remove(row)
        with open(write_to_file, 'w') as wf:
            writer = csv.writer(wf)
            writer.writerows(lines)

    def remove_stopPlace(self):
        # Remove unwanted stopplaces from the file.
        df = pd.read_csv(write_to_file)
        stopPlace_removed = df[~df['stop_id'].astype(str).str.startswith(
            'NSR:StopPlace:')]  # 'NSR:StopPlace:' er et felles punkt der det finnest 2 eller flere stoppesteder.
        stopPlace_removed.to_csv(write_to_file, encoding='utf-8', index=False)


    def load_osm(self):
        #Check if the layer 'OpenStreetMap' exist in the current project. And create it if it dosen't.
        if len(QgsProject.instance().mapLayersByName('OpenStreetMap')):
            pass
        else:
            url_params = 'type=xyz&url=https://tile.openstreetmap.org/%7Bz%7D/%7Bx%7D/%7By%7D.png&zmax=19&zmin=0krs=EPSG3857'
            osm_layer = QgsRasterLayer(url_params, 'OpenStreetMap', 'wms')

            if osm_layer.isValid():
                QgsProject.instance().addMapLayer(osm_layer)
            else:
                QgsMessageLog.logMessage('Laget er ikke gyldig.')

    def load_csv_to_qgis(self):
        # Create a readable file for qgis to load.
        layer_name = ''
        file_to_qgis = "file:///{}{}{}?delimiter={}&xField={}&yField={}".\
            format(os.getcwd(), "/", write_to_file, ",", "stop_lon", "stop_lat")

        # Set the name of the layer.
        if self.dlg.checkBox_begge.isChecked():
            layer_name = 'Vestfold og Telemark'
        elif self.dlg.checkBox_telemark.isChecked():
            layer_name = 'Telemark'
        elif self.dlg.checkBox_vestfold.isChecked():
            layer_name = 'Vestfold'

        # Define the layer and set CRS for the layer.
        layer_stoppesteder = QgsVectorLayer(file_to_qgis, layer_name, "delimitedtext")
        crs = layer_stoppesteder.crs()
        crs.createFromId(4326)
        layer_stoppesteder.setCrs(crs)

        # Check if the layer is valid
        if not layer_stoppesteder.isValid():
            QgsMessageLog.logMessage("Laget er ikke gyldig.")
        else:
            # Add the layer to qgis and hide it.
            QgsProject.instance().addMapLayer(layer_stoppesteder, False)
            # Load OpenStreetMap
            self.load_osm()
            # Insert the map layer as the first layer in the layer group and show it.
            layer_tree = iface.layerTreeCanvasBridge().rootGroup()
            layer_tree.insertChildNode(0, QgsLayerTreeLayer(layer_stoppesteder))

            """
            Check if theres any layers loaded to qgis.
            If there is a layer present in qgis, emit a signal and run the function. 
            """
            if QgsProject.instance().mapLayers():
                try:
                    iface.mapCanvas().mapCanvasRefreshed.connect(self.active_layer_changed())
                except:
                    pass
            else:
                pass

    def active_layer_changed(self):
        # Set the layer name for the layer to be loaded to qgis.
        layer_name = ''
        if self.dlg.checkBox_begge.isChecked():
            layer_name = 'Vestfold og Telemark'
        elif self.dlg.checkBox_telemark.isChecked():
            layer_name = 'Telemark'
        elif self.dlg.checkBox_vestfold.isChecked():
            layer_name = 'Vestfold'

        # Set the active layer as the first layer in the layers array in qgis.
        active_layer = QgsProject.instance().mapLayersByName(layer_name)[0]
        iface.setActiveLayer(active_layer)

        """
        Timer to delay the zoom function until the layer actually is shown on the canvas.
        The signal emitted from the canvas can sometimes be emitted too fast and 
        the zoom function will not work as intended.
        """
        timer = QTimer()
        timer.singleShot(500, self.zoom_to_active_layer)

    def zoom_to_active_layer(self):
        # Zoom to the active layer.
        iface.zoomToActiveLayer()

    def handle_checkBox_begge(self):
        if self.dlg.checkBox_begge.isChecked():
            self.dlg.checkBox_telemark.setChecked(False)
            self.dlg.checkBox_vestfold.setChecked(False)
            self.dlg.label_valg.setText('Vestfold og Telemark')
        else:
            self.dlg.label_valg.setText('')

    def handle_checkBox_telemark(self):
        if self.dlg.checkBox_telemark.isChecked():
            self.dlg.checkBox_begge.setChecked(False)
            self.dlg.checkBox_vestfold.setChecked(False)
            self.dlg.label_valg.setText('Telemark')
        else:
            self.dlg.label_valg.setText('')

    def handle_checkBox_vestfold(self):
        if self.dlg.checkBox_vestfold.isChecked():
            self.dlg.checkBox_begge.setChecked(False)
            self.dlg.checkBox_telemark.setChecked(False)
            self.dlg.label_valg.setText('Vestfold')
        else:
            self.dlg.label_valg.setText('')

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            if os.path.exists(file):
                os.remove(file)
            if os.path.exists(file_t):
                os.remove(file_t)
            if os.path.exists(file_v):
                os.remove(file_v)
            self.first_start = False
            self.dlg = loadStopPlacesBussDialog()

            # Connect the buttons and other widgets to the actions performed in the UI
            self.dlg.checkBox_begge.toggled.connect(self.handle_checkBox_begge)
            self.dlg.checkBox_vestfold.toggled.connect(self.handle_checkBox_vestfold)
            self.dlg.checkBox_telemark.toggled.connect(self.handle_checkBox_telemark)

        # Show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            if self.dlg.checkBox_begge.isChecked():
                self.process_files_telemark()
                self.process_files_vestfold()
                self.combine_files()

            elif self.dlg.checkBox_telemark.isChecked():
                self.process_files_telemark()
                self.file_telemark()

            elif self.dlg.checkBox_vestfold.isChecked():
                self.process_files_vestfold()
                self.file_vestfold()

            self.remove_vehicle_type()
            self.remove_stopPlace()
            self.load_csv_to_qgis()

